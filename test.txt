# 指定したディレクトリのフォルダ容量を表示する関数
function Get-FolderSizes {
    param (
        [string]$Path = ".",
        [string]$Prefix = "",
        [ref]$FolderCount = 0,
        [int]$CurrentDepth = 0,
        [int]$MaxDepth = [int]::MaxValue
    )

    # 現在のフォルダのサイズを取得
    $size = (Get-ChildItem -Path $Path -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    $sizeGB = "{0:N2}" -f ($size / 1GB) + " GB"

    # フォルダ名とサイズを表示
    Write-Host "$Prefix$([System.IO.Path]::GetFileName($Path)) ($sizeGB)"

    # サブフォルダの処理（最大階層に達していない場合）
    if ($CurrentDepth -lt $MaxDepth) {
        $subDirs = Get-ChildItem -Path $Path -Directory -Force
        $currentFolderIndex = 0
        foreach ($subDir in $subDirs) {
            $currentFolderIndex++
            $FolderCount.Value++

            Write-Progress -Activity "Processing folders..." `
                -Status "Current folder: $($subDir.FullName)" `
                -PercentComplete (($currentFolderIndex / $subDirs.Count) * 100)

            # 再帰的に処理
            Get-FolderSizes -Path $subDir.FullName `
                            -Prefix "$Prefix    ├── " `
                            -FolderCount $FolderCount `
                            -CurrentDepth ($CurrentDepth + 1) `
                            -MaxDepth $MaxDepth
        }
    }
}

# メイン処理
param (
    [string]$TargetPath = ".",
    [int]$MaxDepth = [int]::MaxValue  # 階層の最大深さ（デフォルトは無制限）
)

# 進捗状況カウンタ
$folderCount = [ref]0

# 処理開始メッセージ
Write-Host "ディレクトリ: $TargetPath の容量リスト（最大深さ: $MaxDepth）" -ForegroundColor Cyan

# 処理の実行
Get-FolderSizes -Path $TargetPath -FolderCount $folderCount -MaxDepth $MaxDepth

# 処理完了メッセージ
Write-Host "`n処理が完了しました！ 合計フォルダ数: $($folderCount.Value)" -ForegroundColor Green





以下は、PowerShellで指定したパスのフォルダ容量リストを表示するスクリプトです。サブフォルダがある場合は、階層構造も視覚的にわかりやすく表示します。

# 指定したディレクトリのフォルダ容量を表示する関数
function Get-FolderSizes {
    param (
        [string]$Path = ".",
        [string]$Prefix = ""
    )

    # 指定されたパスが有効か確認
    if (-Not (Test-Path $Path)) {
        Write-Host "エラー: 指定したパスは存在しないか無効です。" -ForegroundColor Red
        return
    }

    # 現在のフォルダのサイズを取得
    $size = (Get-ChildItem -Path $Path -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    $sizeGB = "{0:N2}" -f ($size / 1GB) + " GB"

    # フォルダ名とサイズを表示
    Write-Host "$Prefix$([System.IO.Path]::GetFileName($Path)) ($sizeGB)"

    # サブフォルダを取得して再帰的に処理
    $subDirs = Get-ChildItem -Path $Path -Directory -Force
    foreach ($subDir in $subDirs) {
        Get-FolderSizes -Path $subDir.FullName -Prefix "$Prefix    ├── "
    }
}

# メイン処理
param (
    [string]$TargetPath = "."
)

Write-Host "ディレクトリ: $TargetPath の容量リスト" -ForegroundColor Cyan
Get-FolderSizes -Path $TargetPath

実行方法
	1.	上記コードを、たとえば Get-FolderSizes.ps1 というファイル名で保存します。
	2.	PowerShellを開き、保存したスクリプトを実行できるようにスクリプト実行ポリシーを変更します（必要に応じて）:

Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass


	3.	スクリプトを実行します:

.\Get-FolderSizes.ps1 -TargetPath "C:\Path\To\Directory"

出力例

C:\Users\Example\Documents を指定した場合の出力例:

ディレクトリ: C:\Users\Example\Documents の容量リスト
Documents (1.20 GB)
    ├── Folder1 (0.40 GB)
    ├── Folder2 (0.60 GB)
    ├── Folder3 (0.20 GB)
        ├── Subfolder1 (0.05 GB)
        ├── Subfolder2 (0.15 GB)

補足
	•	フォルダサイズの計算には再帰的にすべてのファイルを処理します。大きなフォルダの場合、処理に時間がかかることがあります。
	•	サブフォルダの表示階層はインデント（├──）で表現されています。





#!/bin/bash

# 指定されたパスを変数に代入
TARGET_DIR=${1:-.}  # 引数がない場合はカレントディレクトリを対象

# 指定されたディレクトリが存在するか確認
if [ ! -d "$TARGET_DIR" ]; then
  echo "エラー: 指定したパスは存在しないかディレクトリではありません。"
  exit 1
fi

# フォルダ容量と階層構造を表示する関数
function display_folder_size() {
  local DIR_PATH=$1
  local PREFIX=$2

  # 現在のフォルダ容量を取得
  local SIZE=$(du -sh "$DIR_PATH" 2>/dev/null | cut -f1)
  echo "${PREFIX}${DIR_PATH##*/} (${SIZE})"

  # サブディレクトリを処理
  local SUBDIRS=$(find "$DIR_PATH" -mindepth 1 -maxdepth 1 -type d | sort)
  for SUBDIR in $SUBDIRS; do
    display_folder_size "$SUBDIR" "$PREFIX  ├── "
  done
}

# 結果の表示
echo "ディレクトリ: $TARGET_DIR の容量リスト"
display_folder_size "$TARGET_DIR" ""





以下に、画像の内容を基にチェックリスト形式で校正を作成しました。全体を確認しながら、該当項目ごとに検証を進めてください。

仕様書/設計書の記載内容確認と実装フロー

要件定義
	•	サポート対象機種（GENなど）の確認は行われていますか？
	•	サポート対象のファームウェア（FW）バージョン（または機能バージョン）の確認は済んでいますか？
	•	サポート対象のパネルサイズ（7/9/10インチなど）の確認はされていますか？
	•	各インチサイズにおける管理者設定のサポートメニューの表示有効/無効の確認は行われていますか？
	•	特別な設定（MFPの管理設定表/DipsWなど）が必要かどうか確認されていますか？

画面設計
	•	該当画面の設計案が現行仕様の考慮漏れなく設計され、チーム内レビューが実施されていますか？
	•	バージョンアップ作業の場合、必要な仕様や変更内容が明示されていますか？
	•	日本語版および他言語版の画面ミックスが正確に確認されていますか？
	•	FigmaのURLを開き、ブラウザで表示確認は済んでいますか？
	•	各言語の画面設計が全ページ網羅されていることを確認しましたか？
	•	他言語版サポートが必要な場合、必要な言語が適切に作成されていますか？

実装フロー
	•	単体画面に向けた実装フロー
	•	単体画面向けのバックエンド実装がスタブ想定で行われていますか？
	•	フロントエンド実装がViteサーバーなどでPCブラウザ確認を行いながら進行していますか？
	•	動作確認期間が考慮され、スケジュール設定に含まれていますか？
	•	統合画面に向けた実装フロー
	•	統合画面のバックエンド実装フェーズで必要機能が洗い出されていますか？
	•	必要に応じてKM様やバックエンド担当者への依頼準備が進んでいますか？

コーディング注意書
	•	英語・日本語のコーディングに最低限の情報を提供していますか？
	•	必要に応じてシングルソースのバージョン確認が行われていますか？
	•	ExcelやVSCodeなどのチェック機能を利用し、ミスを防止していますか？

必要に応じてこのチェックリストを補足・更新しながら進めてください。また、不明点があれば教えてください！
