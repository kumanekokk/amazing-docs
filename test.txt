以下は、指定したパス全体のディスク使用量に対する各フォルダの容量の割合を計算し、それを棒グラフと数値で表示するスクリプトです。このスクリプトは、PowerShellのMicrosoft.PowerShell.Utilityモジュールを使用してグラフ化を行います。

スクリプト

# 指定したディレクトリのフォルダ容量を計算して割合を表示する関数
function Get-FolderUsagePercentage {
    param (
        [string]$TargetPath = ".",
        [int]$MaxDepth = 1,          # 階層の最大深さ
        [string]$OutputFolder = "."  # 結果ファイルを保存するフォルダ
    )

    # フォルダごとのサイズを記録する配列
    $folderSizes = @()
    $totalSize = 0

    # フォルダのサイズを再帰的に計算
    function CalculateFolderSize {
        param (
            [string]$Path,
            [int]$CurrentDepth = 0
        )

        # 現在のフォルダのサイズを取得
        $size = (Get-ChildItem -Path $Path -Recurse -Force -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
        $totalSize += $size
        $folderSizes += @{
            Path = $Path
            Size = $size
        }

        # サブフォルダを再帰的に処理
        if ($CurrentDepth -lt $MaxDepth) {
            Get-ChildItem -Path $Path -Directory -Force -ErrorAction SilentlyContinue | ForEach-Object {
                CalculateFolderSize -Path $_.FullName -CurrentDepth ($CurrentDepth + 1)
            }
        }
    }

    # 処理開始
    Write-Host "ディレクトリ: $TargetPath の容量計算を開始します..." -ForegroundColor Cyan
    CalculateFolderSize -Path $TargetPath

    # 合計サイズが0の場合はエラー
    if ($totalSize -eq 0) {
        Write-Host "フォルダ内に有効なデータがありません。" -ForegroundColor Red
        return
    }

    # フォルダごとの割合を計算
    $folderPercentages = $folderSizes | ForEach-Object {
        [PSCustomObject]@{
            Path      = $_.Path
            SizeGB    = "{0:N2}" -f ($_.Size / 1GB)
            Percentage = "{0:N2}" -f (($_.Size / $totalSize) * 100)
        }
    }

    # 結果を表示
    Write-Host "容量の割合計算が完了しました。結果を表示します。" -ForegroundColor Green
    $folderPercentages | Format-Table -AutoSize

    # 棒グラフを作成
    $chartData = $folderPercentages | ForEach-Object { $_.Percentage }
    $chartLabels = $folderPercentages | ForEach-Object { $_.Path }
    $chartTitle = "ディスク使用量: $TargetPath"

    [System.Windows.Forms.Application]::EnableVisualStyles()
    $form = New-Object System.Windows.Forms.Form
    $form.Text = $chartTitle
    $form.Width = 800
    $form.Height = 600

    $chart = New-Object System.Windows.Forms.DataVisualization.Charting.Chart
    $chart.Width = 780
    $chart.Height = 550
    $chart.Left = 10
    $chart.Top = 10

    $chartArea = New-Object System.Windows.Forms.DataVisualization.Charting.ChartArea
    $chart.ChartAreas.Add($chartArea)

    $series = New-Object System.Windows.Forms.DataVisualization.Charting.Series
    $series.ChartType = [System.Windows.Forms.DataVisualization.Charting.SeriesChartType]::Bar
    $chart.Series.Add($series)

    for ($i = 0; $i -lt $chartData.Count; $i++) {
        $series.Points.Add($chartData[$i])
        $series.Points[$i].AxisLabel = $chartLabels[$i]
        $series.Points[$i].Label = "$($chartData[$i])%"
    }

    $form.Controls.Add($chart)
    $form.Add_Shown({ $form.Activate() })
    [System.Windows.Forms.Application]::Run($form)

    # 出力ファイルの保存
    $timestamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
    $outputFile = Join-Path -Path $OutputFolder -ChildPath "FolderUsage_$timestamp.txt"
    $folderPercentages | Out-File -FilePath $outputFile -Encoding UTF8

    Write-Host "結果がファイルに保存されました: $outputFile" -ForegroundColor Green
}

# 実行例
Get-FolderUsagePercentage -TargetPath "C:\Path\To\Directory" -MaxDepth 1

改良点
	1.	フォルダの割合計算
全体のディスク使用量に対する各フォルダの容量の割合を計算。
	2.	棒グラフで視覚化
PowerShellのSystem.Windows.Forms.DataVisualization.Chartingを使用して棒グラフを表示。
	3.	出力結果の保存
比率を含む結果をタイムスタンプ付きのファイルに保存。

実行例

コンソール出力

ディレクトリ: C:\Path\To\Directory の容量計算を開始します...
容量の割合計算が完了しました。結果を表示します。

Path                              SizeGB Percentage
----                              ------ ----------
C:\Path\To\Directory\Folder1      0.40   20.00
C:\Path\To\Directory\Folder2      1.60   80.00
結果がファイルに保存されました: FolderUsage_20241220_153045.txt

棒グラフ

ウィンドウ内に、各フォルダの容量割合を棒グラフで表示。

ファイル出力 (FolderUsage_20241220_153045.txt)

Path                              SizeGB Percentage
----                              ------ ----------
C:\Path\To\Directory\Folder1      0.40   20.00
C:\Path\To\Directory\Folder2      1.60   80.00

必要なモジュール
	•	Microsoft.PowerShell.Utility
グラフを作成するには、PowerShellでWindows Formsを有効にしている必要があります。





以下のスクリプトでは、各フォルダがどのサイズ分布に属するかを記録し、出力結果に追加しました。分布ごとに対応するフォルダリストを作成し、結果をわかりやすく整理します。

改良スクリプト

# 指定したディレクトリのフォルダ容量を表示し、結果をファイルに保存する関数
function Get-FolderSizes {
    param (
        [string]$Path = ".",
        [string]$Prefix = "",
        [ref]$FolderCount = 0,
        [int]$CurrentDepth = 0,
        [int]$MaxDepth = [int]::MaxValue,
        [string]$OutputFile,
        [hashtable]$SizeDistribution
    )

    # 現在のフォルダのサイズを取得
    $size = (Get-ChildItem -Path $Path -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    $sizeGB = $size / 1GB

    # フォルダ名とサイズを記録
    $folderName = $([System.IO.Path]::GetFileName($Path))
    $outputLine = "$Prefix$folderName ({0:N2} GB)" -f $sizeGB
    Write-Host $outputLine
    Add-Content -Path $OutputFile -Value $outputLine

    # サイズ分布にフォルダを分類
    switch ($sizeGB) {
        {$_ -lt 0.1} { $SizeDistribution["<0.1 GB"] += "$folderName ({0:N2} GB)`n" -f $sizeGB }
        {$_ -lt 1.0} { $SizeDistribution["0.1-1 GB"] += "$folderName ({0:N2} GB)`n" -f $sizeGB }
        {$_ -lt 10.0} { $SizeDistribution["1-10 GB"] += "$folderName ({0:N2} GB)`n" -f $sizeGB }
        {$_ -lt 50.0} { $SizeDistribution["10-50 GB"] += "$folderName ({0:N2} GB)`n" -f $sizeGB }
        {$_ -ge 50.0} { $SizeDistribution[">50 GB"] += "$folderName ({0:N2} GB)`n" -f $sizeGB }
    }

    # サブフォルダの処理（最大階層に達していない場合）
    if ($CurrentDepth -lt $MaxDepth) {
        $subDirs = Get-ChildItem -Path $Path -Directory -Force
        $currentFolderIndex = 0
        foreach ($subDir in $subDirs) {
            $currentFolderIndex++
            $FolderCount.Value++

            Write-Progress -Activity "Processing folders..." `
                -Status "Current folder: $($subDir.FullName)" `
                -PercentComplete (($currentFolderIndex / $subDirs.Count) * 100)

            # 再帰的に処理
            Get-FolderSizes -Path $subDir.FullName `
                            -Prefix "$Prefix    ├── " `
                            -FolderCount $FolderCount `
                            -CurrentDepth ($CurrentDepth + 1) `
                            -MaxDepth $MaxDepth `
                            -OutputFile $OutputFile `
                            -SizeDistribution $SizeDistribution
        }
    }
}

# メイン処理
param (
    [string]$TargetPath = ".",
    [int]$MaxDepth = [int]::MaxValue, # 階層の最大深さ（デフォルトは無制限）
    [string]$OutputFolder = "."       # 出力ファイルを保存するフォルダ
)

# タイムスタンプ付きの出力ファイル名を生成
$timestamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
$outputFileName = "FolderSizes_$timestamp.txt"
$outputFilePath = Join-Path -Path $OutputFolder -ChildPath $outputFileName

# 進捗状況カウンタ
$folderCount = [ref]0

# サイズ分布の初期化（対応するフォルダも記録）
$sizeDistribution = @{
    "<0.1 GB"   = ""
    "0.1-1 GB"  = ""
    "1-10 GB"   = ""
    "10-50 GB"  = ""
    ">50 GB"    = ""
}

# 出力ファイルを初期化
if (Test-Path $outputFilePath) {
    Remove-Item -Path $outputFilePath -Force
}
Add-Content -Path $outputFilePath -Value "ディレクトリ: $TargetPath の容量リスト（最大深さ: $MaxDepth）"

# 処理開始メッセージ
Write-Host "ディレクトリ: $TargetPath の容量リストを生成中（最大深さ: $MaxDepth）" -ForegroundColor Cyan

# 処理の実行
Get-FolderSizes -Path $TargetPath -FolderCount $folderCount -MaxDepth $MaxDepth -OutputFile $outputFilePath -SizeDistribution $sizeDistribution

# サイズ分布の出力
Add-Content -Path $outputFilePath -Value "`nフォルダサイズ分布:"
foreach ($key in $sizeDistribution.Keys) {
    $line = "`n$key:"
    Write-Host $line
    Add-Content -Path $outputFilePath -Value $line
    Add-Content -Path $outputFilePath -Value $sizeDistribution[$key]
}

# 処理完了メッセージ
Write-Host "`n処理が完了しました！ 結果は $outputFilePath に保存されました。" -ForegroundColor Green
Write-Host "合計フォルダ数: $($folderCount.Value)" -ForegroundColor Green

改良点
	1.	分布ごとにフォルダ一覧を記録
各サイズ範囲ごとに、対応するフォルダ名とサイズをリストとして保存します。
	2.	出力の見やすさ向上
テキストファイルには、分布名の下にフォルダリストが表示されます。

実行方法

スクリプトの実行方法はこれまでと同じです。

出力例

コンソール出力

ディレクトリ: C:\Path\To\Directory の容量リストを生成中（最大深さ: 2）
Directory (1.20 GB)
    ├── Folder1 (0.40 GB)
    ├── Folder2 (0.60 GB)
    ├── Folder3 (0.20 GB)

<0.1 GB:
0.1-1 GB:
    Folder1 (0.40 GB)
    Folder2 (0.60 GB)
    Folder3 (0.20 GB)
1-10 GB:
10-50 GB:
>50 GB:

処理が完了しました！ 結果は FolderSizes_20241220_153045.txt に保存されました。
合計フォルダ数: 3

ファイル出力 (FolderSizes_20241220_153045.txt)

ディレクトリ: C:\Path\To\Directory の容量リスト（最大深さ: 2）
Directory (1.20 GB)
    ├── Folder1 (0.40 GB)
    ├── Folder2 (0.60 GB)
    ├── Folder3 (0.20 GB)

フォルダサイズ分布:

<0.1 GB:

0.1-1 GB:
Folder1 (0.40 GB)
Folder2 (0.60 GB)
Folder3 (0.20 GB)

1-10 GB:

10-50 GB:

>50 GB:







# 指定したディレクトリのフォルダ容量を表示し、結果をファイルに保存する関数
function Get-FolderSizes {
    param (
        [string]$Path = ".",
        [string]$Prefix = "",
        [ref]$FolderCount = 0,
        [int]$CurrentDepth = 0,
        [int]$MaxDepth = [int]::MaxValue,
        [string]$OutputFile
    )

    # 現在のフォルダのサイズを取得
    $size = (Get-ChildItem -Path $Path -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    $sizeGB = "{0:N2}" -f ($size / 1GB) + " GB"

    # フォルダ名とサイズを記録
    $outputLine = "$Prefix$([System.IO.Path]::GetFileName($Path)) ($sizeGB)"
    Write-Host $outputLine
    Add-Content -Path $OutputFile -Value $outputLine

    # サブフォルダの処理（最大階層に達していない場合）
    if ($CurrentDepth -lt $MaxDepth) {
        $subDirs = Get-ChildItem -Path $Path -Directory -Force
        $currentFolderIndex = 0
        foreach ($subDir in $subDirs) {
            $currentFolderIndex++
            $FolderCount.Value++

            Write-Progress -Activity "Processing folders..." `
                -Status "Current folder: $($subDir.FullName)" `
                -PercentComplete (($currentFolderIndex / $subDirs.Count) * 100)

            # 再帰的に処理
            Get-FolderSizes -Path $subDir.FullName `
                            -Prefix "$Prefix    ├── " `
                            -FolderCount $FolderCount `
                            -CurrentDepth ($CurrentDepth + 1) `
                            -MaxDepth $MaxDepth `
                            -OutputFile $OutputFile
        }
    }
}

# メイン処理
param (
    [string]$TargetPath = ".",
    [int]$MaxDepth = [int]::MaxValue, # 階層の最大深さ（デフォルトは無制限）
    [string]$OutputFolder = "."       # 出力ファイルを保存するフォルダ
)

# タイムスタンプ付きの出力ファイル名を生成
$timestamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
$outputFileName = "FolderSizes_$timestamp.txt"
$outputFilePath = Join-Path -Path $OutputFolder -ChildPath $outputFileName

# 進捗状況カウンタ
$folderCount = [ref]0

# 出力ファイルを初期化
if (Test-Path $outputFilePath) {
    Remove-Item -Path $outputFilePath -Force
}
Add-Content -Path $outputFilePath -Value "ディレクトリ: $TargetPath の容量リスト（最大深さ: $MaxDepth）"

# 処理開始メッセージ
Write-Host "ディレクトリ: $TargetPath の容量リストを生成中（最大深さ: $MaxDepth）" -ForegroundColor Cyan

# 処理の実行
Get-FolderSizes -Path $TargetPath -FolderCount $folderCount -MaxDepth $MaxDepth -OutputFile $outputFilePath

# 処理完了メッセージ
Write-Host "`n処理が完了しました！ 結果は $outputFilePath に保存されました。" -ForegroundColor Green
Write-Host "合計フォルダ数: $($folderCount.Value)" -ForegroundColor Green






以下のPowerShellスクリプトでは、フォルダ容量の結果をコンソールに表示するだけでなく、指定したテキストファイルに保存できるように改良しました。出力は-OutputFile パラメータでファイル名を指定します。

# 指定したディレクトリのフォルダ容量を表示し、結果をファイルに保存する関数
function Get-FolderSizes {
    param (
        [string]$Path = ".",
        [string]$Prefix = "",
        [ref]$FolderCount = 0,
        [int]$CurrentDepth = 0,
        [int]$MaxDepth = [int]::MaxValue,
        [string]$OutputFile
    )

    # 現在のフォルダのサイズを取得
    $size = (Get-ChildItem -Path $Path -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    $sizeGB = "{0:N2}" -f ($size / 1GB) + " GB"

    # フォルダ名とサイズを記録
    $outputLine = "$Prefix$([System.IO.Path]::GetFileName($Path)) ($sizeGB)"
    Write-Host $outputLine
    Add-Content -Path $OutputFile -Value $outputLine

    # サブフォルダの処理（最大階層に達していない場合）
    if ($CurrentDepth -lt $MaxDepth) {
        $subDirs = Get-ChildItem -Path $Path -Directory -Force
        $currentFolderIndex = 0
        foreach ($subDir in $subDirs) {
            $currentFolderIndex++
            $FolderCount.Value++

            Write-Progress -Activity "Processing folders..." `
                -Status "Current folder: $($subDir.FullName)" `
                -PercentComplete (($currentFolderIndex / $subDirs.Count) * 100)

            # 再帰的に処理
            Get-FolderSizes -Path $subDir.FullName `
                            -Prefix "$Prefix    ├── " `
                            -FolderCount $FolderCount `
                            -CurrentDepth ($CurrentDepth + 1) `
                            -MaxDepth $MaxDepth `
                            -OutputFile $OutputFile
        }
    }
}

# メイン処理
param (
    [string]$TargetPath = ".",
    [int]$MaxDepth = [int]::MaxValue, # 階層の最大深さ（デフォルトは無制限）
    [string]$OutputFile = "FolderSizes.txt" # 結果の出力ファイル
)

# 進捗状況カウンタ
$folderCount = [ref]0

# 出力ファイルを初期化
if (Test-Path $OutputFile) {
    Remove-Item -Path $OutputFile -Force
}
Add-Content -Path $OutputFile -Value "ディレクトリ: $TargetPath の容量リスト（最大深さ: $MaxDepth）"

# 処理開始メッセージ
Write-Host "ディレクトリ: $TargetPath の容量リストを生成中（最大深さ: $MaxDepth）" -ForegroundColor Cyan

# 処理の実行
Get-FolderSizes -Path $TargetPath -FolderCount $folderCount -MaxDepth $MaxDepth -OutputFile $OutputFile

# 処理完了メッセージ
Write-Host "`n処理が完了しました！ 結果は $OutputFile に保存されました。" -ForegroundColor Green
Write-Host "合計フォルダ数: $($folderCount.Value)" -ForegroundColor Green

改良点
	1.	-OutputFile パラメータ
	•	結果を指定したファイルに保存する機能を追加しました。デフォルトは FolderSizes.txt です。
	2.	Add-Content コマンド
	•	各フォルダの情報を出力ファイルに追記します。
	3.	ファイルの初期化
	•	スクリプト実行時に既存の出力ファイルを削除し、新しい結果を保存します。

実行方法

1. 全階層を出力して保存

.\Get-FolderSizes.ps1 -TargetPath "C:\Path\To\Directory" -OutputFile "Output.txt"

2. 特定の階層まで出力して保存

.\Get-FolderSizes.ps1 -TargetPath "C:\Path\To\Directory" -MaxDepth 2 -OutputFile "Output.txt"

出力例

Output.txt の内容:

ディレクトリ: C:\Path\To\Directory の容量リスト（最大深さ: 2）
Directory (1.20 GB)
    ├── Folder1 (0.40 GB)
    ├── Folder2 (0.60 GB)
    ├── Folder3 (0.20 GB)

コンソールメッセージ:

ディレクトリ: C:\Path\To\Directory の容量リストを生成中（最大深さ: 2）
Directory (1.20 GB)
    ├── Folder1 (0.40 GB)
    ├── Folder2 (0.60 GB)
    ├── Folder3 (0.20 GB)

処理が完了しました！ 結果は Output.txt に保存されました。
合計フォルダ数: 3

注意点
	•	ファイル名の指定
-OutputFile でフルパスを指定すれば、任意の場所に出力できます。
	•	処理のログ確認
コンソール出力とファイル出力が一致するため、両方で確認できます。






以下は、サブフォルダの表示階層を指定できるように改良したPowerShellスクリプトです。-MaxDepth パラメータを追加し、再帰処理時に現在の深さを追跡します。

# 指定したディレクトリのフォルダ容量を表示する関数
function Get-FolderSizes {
    param (
        [string]$Path = ".",
        [string]$Prefix = "",
        [ref]$FolderCount = 0,
        [int]$CurrentDepth = 0,
        [int]$MaxDepth = [int]::MaxValue
    )

    # 現在のフォルダのサイズを取得
    $size = (Get-ChildItem -Path $Path -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    $sizeGB = "{0:N2}" -f ($size / 1GB) + " GB"

    # フォルダ名とサイズを表示
    Write-Host "$Prefix$([System.IO.Path]::GetFileName($Path)) ($sizeGB)"

    # サブフォルダの処理（最大階層に達していない場合）
    if ($CurrentDepth -lt $MaxDepth) {
        $subDirs = Get-ChildItem -Path $Path -Directory -Force
        $currentFolderIndex = 0
        foreach ($subDir in $subDirs) {
            $currentFolderIndex++
            $FolderCount.Value++

            Write-Progress -Activity "Processing folders..." `
                -Status "Current folder: $($subDir.FullName)" `
                -PercentComplete (($currentFolderIndex / $subDirs.Count) * 100)

            # 再帰的に処理
            Get-FolderSizes -Path $subDir.FullName `
                            -Prefix "$Prefix    ├── " `
                            -FolderCount $FolderCount `
                            -CurrentDepth ($CurrentDepth + 1) `
                            -MaxDepth $MaxDepth
        }
    }
}

# メイン処理
param (
    [string]$TargetPath = ".",
    [int]$MaxDepth = [int]::MaxValue  # 階層の最大深さ（デフォルトは無制限）
)

# 進捗状況カウンタ
$folderCount = [ref]0

# 処理開始メッセージ
Write-Host "ディレクトリ: $TargetPath の容量リスト（最大深さ: $MaxDepth）" -ForegroundColor Cyan

# 処理の実行
Get-FolderSizes -Path $TargetPath -FolderCount $folderCount -MaxDepth $MaxDepth

# 処理完了メッセージ
Write-Host "`n処理が完了しました！ 合計フォルダ数: $($folderCount.Value)" -ForegroundColor Green

改良点
	1.	-MaxDepth パラメータ
	•	再帰処理の最大深さを指定できるようにしました。
	•	CurrentDepth パラメータを追跡して、現在の深さと比較します。
	2.	デフォルト値
	•	-MaxDepth を指定しない場合、デフォルトで無制限（[int]::MaxValue）になります。

実行方法

次のようにスクリプトを実行します:

1. 全階層を表示（デフォルト動作）

.\Get-FolderSizes.ps1 -TargetPath "C:\Path\To\Directory"

2. 特定の階層まで表示

.\Get-FolderSizes.ps1 -TargetPath "C:\Path\To\Directory" -MaxDepth 2

出力例

全階層表示

ディレクトリ: C:\Path\To\Directory の容量リスト（最大深さ: ∞）
Directory (1.20 GB)
    ├── Folder1 (0.40 GB)
    ├── Folder2 (0.60 GB)
    ├── Folder3 (0.20 GB)
        ├── Subfolder1 (0.05 GB)
        ├── Subfolder2 (0.15 GB)

処理が完了しました！ 合計フォルダ数: 5

階層2まで表示

.\Get-FolderSizes.ps1 -TargetPath "C:\Path\To\Directory" -MaxDepth 2

ディレクトリ: C:\Path\To\Directory の容量リスト（最大深さ: 2）
Directory (1.20 GB)
    ├── Folder1 (0.40 GB)
    ├── Folder2 (0.60 GB)
    ├── Folder3 (0.20 GB)

処理が完了しました！ 合計フォルダ数: 3

注意点
	•	パフォーマンス最適化
-MaxDepth を適切に設定することで、深い階層を持つフォルダの処理時間を短縮できます。
	•	動作確認
階層数が多い場合でも正常に処理されることを確認してください。








# 指定したディレクトリのフォルダ容量を表示する関数
function Get-FolderSizes {
    param (
        [string]$Path = ".",
        [string]$Prefix = "",
        [ref]$FolderCount = 0,
        [int]$CurrentDepth = 0,
        [int]$MaxDepth = [int]::MaxValue
    )

    # 現在のフォルダのサイズを取得
    $size = (Get-ChildItem -Path $Path -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    $sizeGB = "{0:N2}" -f ($size / 1GB) + " GB"

    # フォルダ名とサイズを表示
    Write-Host "$Prefix$([System.IO.Path]::GetFileName($Path)) ($sizeGB)"

    # サブフォルダの処理（最大階層に達していない場合）
    if ($CurrentDepth -lt $MaxDepth) {
        $subDirs = Get-ChildItem -Path $Path -Directory -Force
        $currentFolderIndex = 0
        foreach ($subDir in $subDirs) {
            $currentFolderIndex++
            $FolderCount.Value++

            Write-Progress -Activity "Processing folders..." `
                -Status "Current folder: $($subDir.FullName)" `
                -PercentComplete (($currentFolderIndex / $subDirs.Count) * 100)

            # 再帰的に処理
            Get-FolderSizes -Path $subDir.FullName `
                            -Prefix "$Prefix    ├── " `
                            -FolderCount $FolderCount `
                            -CurrentDepth ($CurrentDepth + 1) `
                            -MaxDepth $MaxDepth
        }
    }
}

# メイン処理
param (
    [string]$TargetPath = ".",
    [int]$MaxDepth = [int]::MaxValue  # 階層の最大深さ（デフォルトは無制限）
)

# 進捗状況カウンタ
$folderCount = [ref]0

# 処理開始メッセージ
Write-Host "ディレクトリ: $TargetPath の容量リスト（最大深さ: $MaxDepth）" -ForegroundColor Cyan

# 処理の実行
Get-FolderSizes -Path $TargetPath -FolderCount $folderCount -MaxDepth $MaxDepth

# 処理完了メッセージ
Write-Host "`n処理が完了しました！ 合計フォルダ数: $($folderCount.Value)" -ForegroundColor Green





以下は、PowerShellで指定したパスのフォルダ容量リストを表示するスクリプトです。サブフォルダがある場合は、階層構造も視覚的にわかりやすく表示します。

# 指定したディレクトリのフォルダ容量を表示する関数
function Get-FolderSizes {
    param (
        [string]$Path = ".",
        [string]$Prefix = ""
    )

    # 指定されたパスが有効か確認
    if (-Not (Test-Path $Path)) {
        Write-Host "エラー: 指定したパスは存在しないか無効です。" -ForegroundColor Red
        return
    }

    # 現在のフォルダのサイズを取得
    $size = (Get-ChildItem -Path $Path -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    $sizeGB = "{0:N2}" -f ($size / 1GB) + " GB"

    # フォルダ名とサイズを表示
    Write-Host "$Prefix$([System.IO.Path]::GetFileName($Path)) ($sizeGB)"

    # サブフォルダを取得して再帰的に処理
    $subDirs = Get-ChildItem -Path $Path -Directory -Force
    foreach ($subDir in $subDirs) {
        Get-FolderSizes -Path $subDir.FullName -Prefix "$Prefix    ├── "
    }
}

# メイン処理
param (
    [string]$TargetPath = "."
)

Write-Host "ディレクトリ: $TargetPath の容量リスト" -ForegroundColor Cyan
Get-FolderSizes -Path $TargetPath

実行方法
	1.	上記コードを、たとえば Get-FolderSizes.ps1 というファイル名で保存します。
	2.	PowerShellを開き、保存したスクリプトを実行できるようにスクリプト実行ポリシーを変更します（必要に応じて）:

Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass


	3.	スクリプトを実行します:

.\Get-FolderSizes.ps1 -TargetPath "C:\Path\To\Directory"

出力例

C:\Users\Example\Documents を指定した場合の出力例:

ディレクトリ: C:\Users\Example\Documents の容量リスト
Documents (1.20 GB)
    ├── Folder1 (0.40 GB)
    ├── Folder2 (0.60 GB)
    ├── Folder3 (0.20 GB)
        ├── Subfolder1 (0.05 GB)
        ├── Subfolder2 (0.15 GB)

補足
	•	フォルダサイズの計算には再帰的にすべてのファイルを処理します。大きなフォルダの場合、処理に時間がかかることがあります。
	•	サブフォルダの表示階層はインデント（├──）で表現されています。





#!/bin/bash

# 指定されたパスを変数に代入
TARGET_DIR=${1:-.}  # 引数がない場合はカレントディレクトリを対象

# 指定されたディレクトリが存在するか確認
if [ ! -d "$TARGET_DIR" ]; then
  echo "エラー: 指定したパスは存在しないかディレクトリではありません。"
  exit 1
fi

# フォルダ容量と階層構造を表示する関数
function display_folder_size() {
  local DIR_PATH=$1
  local PREFIX=$2

  # 現在のフォルダ容量を取得
  local SIZE=$(du -sh "$DIR_PATH" 2>/dev/null | cut -f1)
  echo "${PREFIX}${DIR_PATH##*/} (${SIZE})"

  # サブディレクトリを処理
  local SUBDIRS=$(find "$DIR_PATH" -mindepth 1 -maxdepth 1 -type d | sort)
  for SUBDIR in $SUBDIRS; do
    display_folder_size "$SUBDIR" "$PREFIX  ├── "
  done
}

# 結果の表示
echo "ディレクトリ: $TARGET_DIR の容量リスト"
display_folder_size "$TARGET_DIR" ""





以下に、画像の内容を基にチェックリスト形式で校正を作成しました。全体を確認しながら、該当項目ごとに検証を進めてください。

仕様書/設計書の記載内容確認と実装フロー

要件定義
	•	サポート対象機種（GENなど）の確認は行われていますか？
	•	サポート対象のファームウェア（FW）バージョン（または機能バージョン）の確認は済んでいますか？
	•	サポート対象のパネルサイズ（7/9/10インチなど）の確認はされていますか？
	•	各インチサイズにおける管理者設定のサポートメニューの表示有効/無効の確認は行われていますか？
	•	特別な設定（MFPの管理設定表/DipsWなど）が必要かどうか確認されていますか？

画面設計
	•	該当画面の設計案が現行仕様の考慮漏れなく設計され、チーム内レビューが実施されていますか？
	•	バージョンアップ作業の場合、必要な仕様や変更内容が明示されていますか？
	•	日本語版および他言語版の画面ミックスが正確に確認されていますか？
	•	FigmaのURLを開き、ブラウザで表示確認は済んでいますか？
	•	各言語の画面設計が全ページ網羅されていることを確認しましたか？
	•	他言語版サポートが必要な場合、必要な言語が適切に作成されていますか？

実装フロー
	•	単体画面に向けた実装フロー
	•	単体画面向けのバックエンド実装がスタブ想定で行われていますか？
	•	フロントエンド実装がViteサーバーなどでPCブラウザ確認を行いながら進行していますか？
	•	動作確認期間が考慮され、スケジュール設定に含まれていますか？
	•	統合画面に向けた実装フロー
	•	統合画面のバックエンド実装フェーズで必要機能が洗い出されていますか？
	•	必要に応じてKM様やバックエンド担当者への依頼準備が進んでいますか？

コーディング注意書
	•	英語・日本語のコーディングに最低限の情報を提供していますか？
	•	必要に応じてシングルソースのバージョン確認が行われていますか？
	•	ExcelやVSCodeなどのチェック機能を利用し、ミスを防止していますか？

必要に応じてこのチェックリストを補足・更新しながら進めてください。また、不明点があれば教えてください！
